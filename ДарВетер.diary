Среда, 6 января 2016, 13:55:21
Первая тестовая запись в дневник разработки. Я наконец его доделал)
Среда, 6 января 2016, 21:06:57
Обозначу TODO_List. Можно было бы, конечно, подправить управление в главном меню: управление клавишами, а не командами, автодополнение и т.д., но без этого можно обойтись, надо сконцентрироваться на необходимом. Но кое-что допилить всё-таки нужно: 1) сокрытие пароля при вводе, а то совсем уж смешно выглядит; 2) хранить не пароль, а его хэш; 3) шифрование файла дневника.
Более отдалённый TODO. Реализовать систему плагинов в ядре и первый плагин - служебный - окно графического ввода-вывода. Затем дневник тоже вынести в отдельный плагин и усовершенствовать. Всё-таки сделать систему логирования.
По части разработки графического модуля. В первую очередь нужно определить интерфейс общения его с ядром. Ясно, что это должно быть обычное системное окно, реагирующее на действия мыши и клавиатуры, захватывающее фокус и работающее в паралельном режиме с консолью, в которой было запущено ядро.
При этом поведение при том же нажатии и перемещении мыши в одних случаях будет рисованием линии, в других - перетаскиванием символа под мышью, в третьих - поворотом камеры обзора. Это зависит от типа файла открытого для редактирования в окне и от контекста в этом файле. Если мы имеем дело с графической разработкой алгоритма, то нужно иметь представление о доступных блоках.
1) в интерфейсе нужен функционал для загрузки ядром плагина и получения индекса интерфейса загруженного плагина (1. 2) работа с файлами-проектами идёт через ядро, следовательно оно должно предоставлять функционал для открытия и закрытия файла (2. вновь подгружаемые плагины могут=будут влиять на поведение графического модуля в ответ на действия пользователя. то есть вместе с получением индекса возможностей нужно переписывать обработчики. звучит не очень. на этой "радостной" ноте и закончу.
Четверг, 14 января 2016, 02:06:56
Наконец немного утряс архитектуру интерфейса. Теперь глобально за работу ядра или плагина отвечают классы, унаследованные от базового класса модуля. В них есть словарь ключ-команда. За команды отвечают классы наследуемые от абстрактного класса команд. На каждую команду новый класс ради лишь одного объекта во время работы. Зато получаем возможность хранить все команды в одном словаре и обработчики легко понятно куда писать и как вызывать. Короче, с командами разобрался. Осталось разобраться с необходимыми глобальными переменными. Их хорошо бы определить как члены класса описывающего данный модуль. Но команды слухом не слыхивали про модуль, к которому относятся. Правда можно в базовой команде хранить указатель на (в некотором смысле) родительский класс модуля. Всё потихоньку встаёт на свои места. До конца хорошо оформить и можно выделять этот дневник в отдельный модуль и начинать писать графику (ням-ням).
