//
// Created by anton on 05.09.18.
//

#ifndef SPIKARD_PARSER_HPP
#define SPIKARD_PARSER_HPP

#include <vector>

#include "lexer.hpp"
#include "../proof/named_node.hpp"

namespace Parser2
{

/// Отвечает за описание границ имени и его аргументных мест
struct NameGaps
{
    typedef std::pair<size_t, size_t> GapBounds;
    std::vector<GapBounds> _args;
    size_t _ownLength;
    size_t _fullLen;

    explicit NameGaps(size_t ownLength)
        : _ownLength(ownLength), _fullLen(ownLength) {}
    void add(size_t from, size_t to) {
        _args.emplace_back(from, to);
        _fullLen += (to - from);
    }
    size_t getFullLen()
    { return _fullLen; }
};

/**
 * Задача данного этапа - построить дерево разбора имён. Точнее семейство всех возможных деревьев.
 *
 * Дерево храним в виде вектора элементов treeStorage и возможно понадобится второй вектор forProcess для необработанных элементов.
 *
 * Особенности элемента дерева:
 * - Пока дерево не до конца выстроено будут возникать необработанне куски строки.
 *  С точки зрения предыдущего узла они уже его потомки. Но их внутреннее устройство еще не выделено.
 * - Чтобы избежать манипулирования LexemeSequence, имя будет представлено парой чисел [begin, end) - смещения над входной строкой.
 * - При сборке терма понадобится обход дерева сверху вниз, значит узел должен хранить список своих потомков.
 * - В процессе разбора выражения могут появляться новые имена. Их область видимости будет ограничена
 * символом в котором были определены.
 * - Метод для получения NSI в данном узле реализуется через рекурсивный вызов: родитель (узлу нужна ссылка
 *  на родителя) отдаёт свой NSI к которому добавлены (если ещё нет!) символы его родителя. Условие "если ещё нет" при
 *  обходе от потомков к родителю обеспечивает перегрузку имени.
 * - Если узел не предполгает введения новых имён, регистрация происход в родителе. Таким образом имя, определённое
 * в недрах терма-условия, будет видно в пределах символа, где оно ожидалось.
 * - В тех местах, где возможно сразу несколько вариантнов, дерево будет расслаиваться. То есть потомок может
 * превращаться в (виртуальный) узел расслоения.
 *
 * Устройство элемента:
 * 1) границы части строки за которую отвечает
 * 2) ссылка на родительский узел в виде индекса в treeStorage
 * 3) само имя LexemeSequence
 * 4) список потомков (или вариантов) в виде индексов в treeStorage (возможно пустой)
 * 5) отметка является ли виртуальным узлом расслоения
 * 6) отметка ожидается в данном узле ввод новых имён
 * 7) NSI
 *
 * Корень создавать виртуальным. После построения семейства деревьев для каждого будем считать кол-во
 * имён, которые потребовалось в нём ввести, и выбирать наименьший вариант.
 *
 * Ход роста дерева:
 * 1) Элемент имеет границы разбираемого участка строки и ссылку на родителя
 * 2) Получение NSI для данного узла
 * 3) Получаем список подходящих имён. Список может быть длины А) >1, Б) 1, В) 0
 *  A) Узел помечается как виртуальный, создаются потомки-случаи для каждого варианта
 *  Б) В качестве имени узла записывается найденный вариант. При необходимости выставляется отметка новых имён
 *  В) Данная последовательность целиком регистрируется как имя, завершение процесса роста.
 * А-4) Для каждого случая нужно создать потомков в соответствии с пропусками в имени, рекурсия к п. 1)
 * Б-4) Создаются узлы потомков для пропусков имени, рекурсия к п. 1)
 *
 * Элементу требуются функции:
 * - Конструктор от границ строки
 * - Получение списка имён (index())
 * - Регистрация имени (registerName(name))
 * - Метод приписывания имени узлу с созданием потомков по информации о пропусках в имени и выставлением отметки для NSI
 * - Метод становления узла виртуальным с созданием случаев
 * - Для последнего нужен конструктор от информации о символе и пропусках (используя тот метод приписывания)
 *
 * И последнее, что нужно использовать, это информация о Типах. Найдя подходящее имя, мы знаем
 * Типы его аргументов if any и можем сузить отсев имён на следующем шаге и не порождать заведомо ложные случаи.
 * Однако, имена, допускающие связывание (может быть полезно разделять на те, где связывание возможно и где обьязательно?), без
 * него имеют один Тип, а после другой. Например, Natural->Real становится просто Real.
 * Что если считать, что имя со связыванием имеет тот Тип, который будет после связывания?
 */

/**
 * N.B. Функция! бывает запись f(x) а может быть (f+g)'(x)
 * при используемом методе работы с пропусками функция будет объявлена f(\cdot) и не будет признана подходящим
 * именем во втором случае.
 *  А если смотреть на скобки как на имя?
 *  И запятая как порождающий элемент декартового произведения, конкатенация списков!
 * Общий Тип Кортеж и Тип Функция, тогда скобки это конкструкция \cdot:Функция(\cdot:Кортеж)
 *
 * И, рассматривая скобки как одну из особых конструкций, можно перестать думать, что имя f поменяло
 * тип, став f(x). Раз и навсегда f:Map(Real, Real) а х:Real. Однако какой тогда Тип у \cdot:Функция(\cdot:Кортеж)?
 * Он зависит от того какой Тип у функции. Привет, зависимые Типы!
 * Пусть пока будет any, без зависимых Типов можно пока обойтись.
 */

struct NamesTreeElem
{
    std::pair<size_t, size_t> _bounds;

    LexemeSequence _name;
    std::vector<size_t> _subElemsIndices;

    size_t _parent;
    bool isSymbolVars;
    NameSpaceIndex _ownNS;

    explicit NamesTreeElem(size_t from, size_t to)
        : _bounds(std::make_pair(from, to)) {}

    const NameSpaceIndex& index();
    void registerName(const LexemeSequence& name);
};

struct NamesTree
{
    const LexemeSequence& _input;
    std::vector<NamesTreeElem> _treeStorage;
    std::vector<size_t> _forProcess;

    NamesTree(const LexemeSequence& input) : _input(input) {
        _treeStorage.emplace_back(0, input.size());
        _forProcess.push_back(0);
    }
};

struct PartialResolved
{
    typedef std::vector<LexemeSequence> result_type;

    size_t indent;
    result_type recognized;

    PartialResolved(size_t indent, result_type recognized)
        : indent(indent), recognized(std::move(recognized)) {}
    bool operator< (const PartialResolved& two) const
    { return (indent < two.indent); }
};

class Parser
{
public:
    const Node* _where;
    std::vector<LexemeSequence> namesDefined;

    Parser(Node* where);

    Terms* parse(CurAnalysisData& source);
};

Terms* parse(Node* where, std::string source);
}

#endif //SPIKARD_PARSER_HPP
